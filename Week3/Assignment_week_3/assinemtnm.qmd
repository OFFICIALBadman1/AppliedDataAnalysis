---
title: "Week 3 Examination Assignments"
author: "Isak Jonsson Zachari"
date: "2025-04-13"
format: 
  html:
    toc: true                # Table of Contents
    code-fold: true          # Collapse code chunks
    code-tools: true         # Add code copy buttons
    theme: cosmo             # Clean theme
    css: styles.css          # Optional custom CSS
---


## 1. Import and Inspect Data

<!-- Original: Importerar och inspekterar datan -->

```{r}
library(tidyverse)    
library(readr)   


df_fb <- read_delim("Week3/Assignment_week_3/dataset_Facebook.csv", delim=";")

glimpse(df_fb)

str(df_fb)
head(df_fb)
summary(df_fb)

```

## 2. Rename Variables
<!-- Original: Ändra namn på variablarna -->
```{r}

df_fb <- df_fb %>%
    rename(
    page_total_likes           = `Page total likes`,
    post_type                  = Type,
    category_code              = Category,
    post_month                 = `Post Month`,
    post_weekday               = `Post Weekday`,
    post_hour                  = `Post Hour`,
    paid_code                  = Paid,
    lifetime_post_total_reach  = `Lifetime Post Total Reach`,
    lifetime_post_total_impressions = `Lifetime Post Total Impressions`,
    lifetime_engaged_users     = `Lifetime Engaged Users`,
    lifetime_post_consumers    = `Lifetime Post Consumers`,
    lifetime_post_consumptions = `Lifetime Post Consumptions`,
    lifetime_post_impressions_liked = `Lifetime Post Impressions by people who have liked your Page`,
    lifetime_post_reach_like   = `Lifetime Post reach by people who like your Page`,
    lifetime_page_engaged      = `Lifetime People who have liked your Page and engaged with your post`,
    total_interactions         = `Total Interactions`
    )

str(df_fb)
glimpse(df_fb)
summary(df_fb)


```

## 3. Convert to Correct Data Types
<!-- Original: Ändrar till korrekt datatyp -->

```{r}

library(dplyr)

df_fb <- df_fb %>%
  mutate(
    page_total_likes = as.numeric(page_total_likes),
    post_hour = as.numeric(post_hour),
    lifetime_post_total_reach = as.numeric(lifetime_post_total_reach),
    lifetime_post_total_impressions = as.numeric(lifetime_post_total_impressions),
    lifetime_engaged_users = as.numeric(lifetime_engaged_users),
    lifetime_post_consumers = as.numeric(lifetime_post_consumers),
    lifetime_post_consumptions = as.numeric(lifetime_post_consumptions),
    lifetime_post_impressions_liked = as.numeric(lifetime_post_impressions_liked),
    lifetime_post_reach_like = as.numeric(lifetime_post_reach_like),
    lifetime_page_engaged = as.numeric(lifetime_page_engaged),
    comment = as.numeric(comment),
    like = as.numeric(like),
    share = as.numeric(share),
    total_interactions = as.numeric(total_interactions),
    category_code = as.integer(category_code),
    post_month = as.integer(post_month),
    post_weekday = as.integer(post_weekday),
    paid_code = as.integer(paid_code),
    # Skapar nu kategorisk faktor    
    category = factor(category_code,
                      levels = c(1, 2, 3),
                      labels = c("action", "product", "inspiration")),
    month_name = factor(post_month,
                        levels = 1:12,
                        labels = month.name),
    weekday_name = factor(post_weekday,
                          levels = 1:7,
                          labels = c("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday")),
    paid = factor(paid_code,
                  levels = c(0, 1),
                  labels = c("Not paid", "Paid"))
  )


# Check if data types were correctly converted
# Original: kontrollerar så det är korrekt ändrat
str(df_fb)
glimpse(df_fb)

```



2. Examination Assignment 2 – Measures of location and variability

```{r}
library(tidyverse)
library(ggplot2)
# Calculate mean, trimmed mean and median for the numeric variable 'total_interactions'
# Original: Beräknar medelvärde, trimmat medel och median för 1 numerisk variabel
df_location <- df_fb %>%
   summarise(
    Mean = mean(total_interactions, na.rm = TRUE),
    `Trimmed_Mean_(10%)` = mean(total_interactions, trim = 0.10, na.rm = TRUE),
    Median = median(total_interactions, na.rm = TRUE)
  )
df_location
summary(df_fb$total_interactions)
# 3rd quartile is 228.5, maximum value is 6334

# Analysis:
# Mean: 212
# Trimmed mean: 149 (removes 10% highest/lowest values before calculating - indicates many high values)
# Median: 124

# Create boxplot
# Original: Skapar boxplot
df_fb %>%
    ggplot(aes(y=total_interactions))+
    geom_boxplot()+
    scale_y_continuous(limits = c(0, 3000)) +
    labs(title="Boxplot of Total Interactions", y="total_interactions")+
    theme_minimal()



```


## Create Histogram
<!-- Original: Lite histogram -->
```{r}
library(tidyverse)


# Histogram of raw data
# Original: Histogram för rådata
df_fb %>%
  ggplot(aes(x = total_interactions)) +
  geom_histogram(binwidth = 40, fill = "blue", alpha = 0.7) +
  labs(title = "Histogram of Total Interactions", x = "Total Interactions", y = "Count") +
  theme_minimal()


# The data is highly right-skewed (positive skew)
# Original: Mycket höger snedfördelad data




```


## Does total_interactions have outliers? If so, which ones?
<!-- Original: Har total_interactions några uteliggare? Isåfall vilka? -->
```{r}

# Identification of outliers using IQR method
# Original: Identifiering av uteliggare med IQR
# Determine the number of outliers outside the IQR boundaries
# Original: Tar reda på antalet uteliggare utanför IQR
limits <- df_fb %>%
  summarise(
      Q1 = quantile(total_interactions, 0.25, na.rm = TRUE),
      Q3 = quantile(total_interactions, 0.75, na.rm = TRUE),
      IQR_val = IQR(total_interactions, na.rm = TRUE)
    ) %>%
    mutate(
      lower_bound = Q1 - 1.5 * IQR_val,
      upper_bound = Q3 + 1.5 * IQR_val
    )
limits

# Get the boundary values
# Original: Hämta gränsvärdena
lower_bound <- limits %>% pull(lower_bound)
upper_bound <- limits %>% pull(upper_bound)

# Filter and count the number of outliers
# Original: Filtrera ut och räkna antalet outliers
df_fb %>%
  filter(total_interactions < lower_bound | total_interactions > upper_bound) %>%
    summarise(outlier_count = n())
# There are 40 outliers
# Original: 40 st uteliggare finns

```

```{r}
#Beärkning a variabilitetmått

# Calculation of variability measures
# Original: Beräkning av variabilitetmått
df_variability <- df_fb %>%
  summarise(
    Variance = var(total_interactions, na.rm = TRUE),
    SD = sd(total_interactions, na.rm = TRUE),
    MAD = mad(total_interactions, na.rm = TRUE), # standard MAD (mean absolute deviation from median)
    Min = min(total_interactions, na.rm = TRUE),
    Max = max(total_interactions, na.rm = TRUE),
    Range = max(total_interactions, na.rm = TRUE) - min(total_interactions, na.rm = TRUE),
    IQR = IQR(total_interactions, na.rm = TRUE)
  )
df_variability

# Analysis:
# The data is clearly right-skewed. The majority of observations tend to cluster around the median value (124),
# in the lower part of the range and within the IQR (approximately 71-229). However, a few observations (outliers)
# with very high values (up to 6334) pull up both the mean and standard deviation. This is likely why we see a
# standard deviation (380) that is much higher than the robust measure, MAD (100).

```


3. Examination Assignment 3 – Data distributions

```{r}
# 3.1: Calculate different quantiles
# Original: Beräknar olika kvartiler
# Solution using quantile() function
# Original: Lösning använd quantile()
k = c(0.05,0.25,0.5,0.75,0.95) # quantiles from 5% to 95%

quantiles_total_interactions <- quantile(df_fb$total_interactions, k, na.rm=TRUE)

print(quantiles_total_interactions)
# Results:
#   5%    25%    50%    75%    95%
#   9.95  71.00 123.50 228.50 605.85

```

3.2 SKapa lite plottar
```{r}
library(ggplot2)

# Create a histogram
# Original: skapar ett histogram
df_fb %>%
  ggplot(aes(x=total_interactions))+
  geom_histogram(binwidth=40, fill = "lightblue", color = "black")+
  scale_x_continuous(limits = c(0, 606))+  # Zoom in to see up to the 95th percentile (606)
  labs(
    title="Histogram of Total Interactions",
    subtitle="Distribution with majority between ~10 and ~606",
    x="Total Interactions",
    y="Number of Observations"
  )+
  theme_minimal()



```


```{r}

# Create a density plot
df_fb %>%
  ggplot(aes(x=total_interactions))+
  geom_density(fill = "lightblue", color = "black")+
  scale_x_continuous(limits = c(0, 606)) +  # Zoom in similar to the histogram
  labs(
    title = "Density Plot of Total Interactions",
    subtitle = "Shows the distribution of observations",
    x = "Total Interactions",
    y = "Density"
  )+
  theme_minimal()

# Analysis of histogram and density plot:
# The data shows a clear right-skewed (positive) distribution. There is a prominent peak in the
# 0-300 range where the frequency is highest. The mean is not robust in this case, so the median
# should be preferred as a measure of central tendency.

```

## Create boxplots by category (action, product, inspiration)
<!-- Original: Skapa flera boxplot för category, action, product, inspiration -->

```{r}

df_fb %>%
  filter(total_interactions<610) %>% # Filter out observations above the 95th percentile
    ggplot(aes(x=category, y=total_interactions, fill=category))+
    geom_boxplot()+
    labs(
    title = "Boxplot of Total Interactions by Category",
    x = "Category",
    y = "Total Interactions"
  )

# Analysis:
# The Product category has a higher median and generally tends to receive more interactions than Action and Inspiration.

# Outliers: There are several extreme values in each category, which shows that a small percentage of posts
# receive much more attention, which is logical for social media engagement patterns.

```

## Create boxplot by post type (similar to figure 7 "Influence of type on Lifetime post consumers")
<!-- Original: Skapa likt figur 7. "Influence of type på Lifetime post consumers" -->

```{r}
df_fb %>%
  filter(total_interactions<610) %>%
    ggplot(aes(x=post_type, y=total_interactions, fill=post_type))+
    geom_boxplot()+
    labs(
    title = "Total Interactions per Post Type",
    x = "Post Type",          
    y = "Total Interactions"
    )+
    theme_minimal()

# Analysis:
# Video posts often generate more interactions than other types. This may be because video content engages users
# for a longer time (watching, listening, reacting), which increases the likelihood of likes, comments, and shares.
# At the same time, there are many outliers, suggesting that a few video posts may have gone viral or been
# particularly popular.
#
# Status posts also have a fairly high median and wide distribution. One possible interpretation is that text-based
# posts can sometimes generate a lot of discussion (e.g., questions, stories, offers), while others are less interesting.
#
# Photo posts generally rank higher than links but lower than videos and status updates. There are also outliers
# above the median, showing that some photo posts can receive very high interaction rates.
#
# Links: These may lead users away from Facebook (clicking through to external sites), which might reduce the
# likelihood of likes/comments, which seems logical.
#
# Many data points fall below or around the median, while some are very high, indicating that a small number of
# posts drive up the total interactions.



```


Violoinplot 
```{r}
# Create violin plot of lifetime post consumers by weekday
df_fb %>%
  ggplot(aes(x=weekday_name, y=lifetime_post_consumers, fill=weekday_name))+
  geom_violin()+
  theme_minimal()+
  labs(
    title = "Distribution of Lifetime Post Consumers by Weekday",
    x = "Weekday",
    y = "Lifetime Post Consumers"
  )

# Comment:
# Lifetime Post Consumers: The number of UNIQUE users who clicked anywhere on the post during its lifetime.
#
# Most posts have low values (under 500-600), but a few posts raise the numbers, especially on specific days
# such as Sundays (up to around 9000 on certain days).



```



## 4. Exploring Categorical Data: Bar Charts


```{r}
# 4.1 Which category of the variable "Type" was the most commonly used "post type"?
# Original: Vilken kategori av variabeln "Typ" som var den vanligaste använda "post typen"?

# fct_infreq() sorts a factor in descending order based on frequency
# Original: sorterar en factor i fallande ordning baserat på frekvensen
library(ggplot2)

df_fb %>%
  ggplot(aes(x=(fct_infreq(post_type)), fill=post_type))+
  geom_bar()+
  labs(
    title = "Number of Posts by Post Type",
    x = "Post Type",
    y = "Number of Posts"
  ) +
  theme_minimal()

# The most common type is clearly photos.
# Original: Vanligaste typen är helt klart foton.



```


```{r}
# 4.2 Which month had the most posts?
# Original: Vilken månad hade flest inlägg?
library(ggplot2)
library(tidyverse)

df_fb %>% 
  ggplot(aes(x = fct_infreq(month_name), fill = month_name)) +
  geom_bar() +
  labs(
    title = "Number of Posts per Month",
    x = "Month",
    y = "Number of Posts"
  ) +
  theme_minimal()

# October is the month with the most posts per month, approximately 60 posts.
# Original: Oktober är månaden med flest inlägg per månad. 60 stycken.

``` 

### 4.3 Which weekday had the most posts?
<!-- Original: Vilken veckodag hade flest inlägg? -->
 
```{r}
library(ggplot2)
library(tidyverse)
df_fb %>% 
  ggplot(aes(x = fct_infreq(weekday_name), fill = weekday_name)) +
  geom_bar() +
  labs(
    title = "Number of Posts per Weekday",
    x = "Weekday",
    y = "Number of Posts"
  ) +
  theme_minimal()

# Saturdays and Fridays are the days with the most posts. Sunday has slightly more.
# Original: Lördagar och fredag är dom dagar som har flest inlägg. Typ lika många söndag har något mer bara. Kanske

```


### 4.4: What types of posts were most often paid vs. unpaid?
<!-- Original: Vad för typ av inlägg var mest betalda vs icke betalda? -->
```{r}

library(ggplot2)
library(tidyverse)

df_fb %>%
  ggplot(aes(x = fct_infreq(paid), fill = paid)) +
  geom_bar() +
  labs(
    title = "Number of Posts: Paid vs. Unpaid",
    x = "Paid Status",
    y = "Number of Posts"
  ) +
  theme_minimal()

# Most posts are not paid.
# Original: Dom flesta inlägg är inte betalda.

```

5. Examination Assignment 5 – Exploring Correlation

```{r}
library(corrplot)

#5.1 Calculate the Pearson correlation coefficient between ’Lifetime Post total reach’ and 'Lifetime Post total consumers.’ 
cor(df_fb$lifetime_post_total_reach,df_fb$lifetime_post_consumers)

#0.447908 #medelhög posetiv korrelation


#5.2: Korrelationsplot 
# skaapr först df utan na värden
library(tidyr)

df_fb_no_na_lifetime <- df_fb %>%
  select(lifetime_post_total_reach,
  lifetime_post_total_impressions,
  lifetime_engaged_users,
  lifetime_post_consumers,
  lifetime_post_consumptions,
  lifetime_post_impressions_liked,
  lifetime_post_reach_like,
  lifetime_page_engaged
  ) %>%
    drop_na()



cor_matrix <- cor(df_fb_no_na_lifetime, use = "complete.obs", method = "pearson")

corrplot(cor_matrix, 
         method = "color",    # Använder färgade celler
         order = "hclust",    # Ordnar variablerna med hierarkisk klustring
         addCoef.col = "black",  # Visar korrelationskoefficienten med svart text
         tl.col = "black",    # Sätter textfärgen för etiketter till svart
         number.cex = 0.9)    # Justerar storleken på siffrorna

## Comment:
# All variables have positive correlations.
# Some have higher dimensions.
# Reach-related variables are strongly correlated with each other, and engagement variables are strongly 
# correlated with each other but only moderately with reach.

# When proceeding with analysis, we could remove certain variables as they essentially show the same information.

# It would be useful to analyze reach metrics (how many users were reached) with engagement metrics (how many engaged),
# rather than comparing reach metrics with each other or engagement metrics with each other.

```



6. Examination Assignment 6 – Scatterplots and Contours for numeric data


```{r}
# Choosing "lifetime_post_total_reach" (number of unique users who have seen a post) and "lifetime_post_consumers" 
# (number of unique users who have engaged with the post)
# We can assume that a post that reaches more users has the potential to attract more consumers,
# but the relationship is not always linear.

## Creating scatterplots

library(ggplot2)
library(tidyverse) 

df_fb %>%
  ggplot(aes(x=lifetime_post_total_reach, y=lifetime_post_consumers))+
  geom_point(color="steelblue", alpha=0.6)+
  geom_smooth(method = "loess", se = TRUE, color = "darkred") +
  labs(title = "Samband mellan Reach och Post Consumers",
       x = "Lifetime Post Total Reach",
       y = "Lifetime Post Consumers") +
  theme_minimal()


"""
Analys av scatterplotten: Jo högre lifetime post total reach, desto fler lifetime post consumers. Fler visningar tycks leda till fler faktiska interaktioner vilket ju är logiskt. 

Finns dock icke linjär relation, den röda kurvan visar att detta samband inte är helt rak. Vid låga värden av “Reach” ökar “Consumers” snabbt, men sedan planar kurvan ut något i mitten för att återigen stiga vid riktigt höga räckviddsnivåer.


Spridning: Puntkerna ligger rätt så spritt, högt och lågt. Vilket tyder på att andra faktorer också påverkar antalet konsumenter för en given räckvidd. Man kan nå många användare men det betyder inte alltid att man interagerar. 

Man skulle nu kunna göra en regressionsmodell för att analysera sambandet bättre. 
"""


```


## Scatterplot with Density Contours

Jämförelse mellan paid unpaid

```{r}
# 6.2: Scatterplot with contours (completed)
library(ggplot2)
df_fb %>%
  ggplot(aes(x = lifetime_post_total_reach, y = lifetime_post_consumers)) +
  geom_point(color = "steelblue", alpha = 0.6) +
  geom_density_2d(color = "darkred", size = 0.8) +
  labs(title = "Scatterplot med Density-konturer",
       x = "Lifetime Post Total Reach",
       y = "Lifetime Post Consumers") +
  theme_minimal()

# 6.3: Compare by Category as well
df_fb_clean <- df_fb %>% 
  drop_na(lifetime_post_total_reach, lifetime_post_consumers, category)

# Scatterplot differentiated by Category (3 levels)
ggplot(df_fb_clean, aes(x = lifetime_post_total_reach, 
                        y = lifetime_post_consumers, 
                        color = category)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "loess", se = FALSE) +  # Add trend lines for each category
  labs(title = "Scatterplot: Total Reach vs. Post Consumers by Category",
       x = "Lifetime Post Total Reach",
       y = "Lifetime Post Consumers",
       color = "Category") +
  theme_minimal() +
  facet_wrap(~category, scales = "free") +  # Optional: separate panels
  theme(legend.position = "bottom")

# Comment on results
cat("
KOMMENTAR PÅ RESULTATEN:
- Betalda inlägg tenderar att ha högre räckvidd men inte nödvändigtvis proportionellt fler consumers
- Product-kategorin visar starkast samband mellan reach och consumers
- Action och Inspiration har mer spridd relation
")
```

